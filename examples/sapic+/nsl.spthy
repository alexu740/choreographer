theory ChoreoTheory
begin
builtins: asymmetric-encryption
functions: pair/2, priv/1 [private]
let A(A) =
  in(B);
  new Na;
  event Witness(A, B, 'WeakAuthBAAtomicNa', Na);
  out(aenc(pair(A, Na), pk(priv(B))));
  in(X5);
  let X6 = adec(X5, priv(A)) in
    let pair(=B, X8) = X6 in
      let pair(=Na, Nb) = X8 in
        out(aenc(Nb, pk(priv(B))));
        new sid;
        event Request(A, B, 'StrongAuthABAtomicNb', Nb, sid);
        event Secret(Na, A, B);
        0
      else
        0
    else
      0
  else
    0
let B(B) =
  in(A);
  in(X4);
  let X5 = adec(X4, priv(B)) in
    let pair(=A, Na) = X5 in
      new Nb;
      event Witness(B, A, 'StrongAuthABAtomicNb', Nb);
      out(aenc(pair(B, pair(Na, Nb)), pk(priv(A))));
      in(X9);
      let X10 = adec(X9, priv(B)) in
        if X10 = Nb then
          new sid;
          event Request(B, A, 'WeakAuthBAAtomicNa', Na, sid);
          event Secret(Na, A, B);
          0
        else
          0
      else
        0
    else
      0
  else
    0
process: 
  new dishonest;
  event Dishonest(dishonest);
  out(dishonest);
  out(priv(dishonest));
  ! new agent;
  event Honest(agent);
  out(agent);
  out(pk(priv(agent)));
  ! (
    A(agent)
   | 
    B(agent)
  )
lemma secrecy_A_B_Na [output=[spthy]] :
  "All A B x #i #agA #agB. ((Honest(A) @ agA & (Honest(B) @ agB & Secret(x, A, B) @ i)) ==> not(Ex #j. KU(x) @ j))"
lemma weakAuth_B_A_Na [output=[spthy, proverif]] :
  "All B A t #i sid #ag. ((Honest(B) @ ag & Request(A, B, 'WeakAuthBAAtomicNa', t, sid) @ i) ==> Ex #j. Witness(B, A, 'WeakAuthBAAtomicNa', t) @ j)"
lemma strongAuth_A_B_Nb [output=[spthy]] :
  "All A B t #i sid #ag. ((Honest(A) @ ag & Request(B, A, 'StrongAuthABAtomicNb', t, sid) @ i) ==> Ex #j. (Witness(A, B, 'StrongAuthABAtomicNb', t) @ j & not(Ex #i1 #i2 sid1 sid2. ((Request(B, A, 'StrongAuthABAtomicNb', t, sid1) @ i1 & Request(B, A, 'StrongAuthABAtomicNb', t, sid2) @ i2) & not(sid1 = sid2)))))"
export queries :
 "
 query x:bitstring, A:bitstring, B:bitstring; ((event(eSecret(x, A, B)) && event(attacker(x))) ==> (event(eDishonest(A)) || event(eDishonest(B)))).
 query A:bitstring, B:bitstring, sid:bitstring, t:bitstring; ((event(eHonest(A)) && inj-event(eRequest(B, A, sStrongAuthABAtomicNb, t, sid))) ==> inj-event(eWitness(A, B, sStrongAuthABAtomicNb, t))).
 "
end
